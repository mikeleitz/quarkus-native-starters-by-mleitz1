plugins {
    id 'base'
    id 'java'
    // Have to define these here but apply them in a separate line in the subprojects section
    id 'io.quarkus' version "${quarkusPluginVersion}" apply false
    id 'com.mleitz1.quarkus.quarkus-build-helper' apply false
    id 'com.avast.gradle.docker-compose' version '0.17.6' apply false
}

// Configuration for all projects including the root project
allprojects {
    group = 'com.mleitz1.quarkus'
    version = '0.1.1-SNAPSHOT'

    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    apply plugin: 'idea'
    apply plugin: 'java'

    java {
        toolchain {
            // Only support Mandrel v24 currently - TODO support more jdk versions
            languageVersion = JavaLanguageVersion.of(24)
        }
    }

    tasks.withType(Test) {
        jvmArgs = [
                '--add-opens', 'java.base/java.lang=ALL-UNNAMED',
                '--add-opens', 'java.base/java.util=ALL-UNNAMED',
                '--add-opens', 'java.base/java.util.concurrent=ALL-UNNAMED'
        ]
    }

    idea {
        module {
            downloadJavadoc = true
        }
    }
}

// Common configuration by type for subprojects
subprojects {
    // Common configuration for all subprojects
    apply plugin: 'io.quarkus'
    apply plugin: 'com.mleitz1.quarkus.quarkus-build-helper'
    apply plugin: 'com.avast.gradle.docker-compose'

    // Adding behavior to quarkus plugin's integration tests
    // when someone runs the integration test on the subprojects
    // there's some docker containers that need to be
    // created to run those example tests
    tasks.named('quarkusIntTest', Test) {
        // Docker Compose lifecycle - start before tests
        dependsOn 'composeUp'

        // Docker Compose lifecycle - stop after tests (even if they fail)
        finalizedBy 'composeDown'

        // Integration tests should run after native build
        dependsOn 'quarkusBuild'

        // Configure test reporting
        reports {
            html.required = true
            junitXml.required = true
        }

        // Create a little report for these native integration tests
        testLogging {
            events "passed", "skipped", "failed", "standardOut", "standardError"
            exceptionFormat "full"
            showCauses true
            showExceptions true
            showStackTraces true
            showStandardStreams false
        }

        // Print summary at the end
        afterSuite { desc, result ->
            def reportFile = file("build/reports/tests/integrationTest/index.html")

            if (!desc.parent) { // Only execute for the root suite
                println ""
                println "Integration Test Results:"
                println "========================"
                println "Tests: ${result.testCount}"
                println "Passed: ${result.successfulTestCount}"
                println "Failed: ${result.failedTestCount}"
                println "Skipped: ${result.skippedTestCount}"
                println "Success rate: ${result.successfulTestCount}/${result.testCount} (${Math.round(result.successfulTestCount * 100 / result.testCount)}%)"
                println "========================"

                if (reportFile.exists()) {
                    println "HTML Report: file://${reportFile.absolutePath}"
                }
            }
        }

        // Optional: Add some environment variables for tests
        environment 'POSTGRES_HOST', 'localhost'
        environment 'POSTGRES_PORT', '5432'
        environment 'POSTGRES_DB', 'quarkus_test'
        environment 'POSTGRES_USER', 'quarkus-admin'
        environment 'POSTGRES_PASSWORD', 'mysecretpassword'
    }

    // Make build depend on integration tests
    tasks.named('build') {
        dependsOn 'quarkusIntTest'
    }
}

// Helper method to create aggregate tasks
def createAggregateTask(String taskName, String targetTaskName, String successMessage) {
    tasks.register(taskName) {
        dependsOn subprojects*.tasks*.matching { it.name == targetTaskName }
        description = "${taskName.capitalize()} all subprojects"
        group = 'build'
        doLast {
            println successMessage
        }
    }
}

// Root project tasks
createAggregateTask('buildAll', 'build', 'All subprojects have been built successfully!')
createAggregateTask('cleanAll', 'clean', 'All subprojects have been cleaned successfully!')

// Display all projects in the build
tasks.register('listProjects') {
    doLast {
        def maxNameLength = rootProject.allprojects.collect { it.name.length() }.max()

        println "Root project: ${rootProject.name}"
        println "Subprojects:"
        subprojects.each { project ->
            println "- ${project.name.padRight(maxNameLength)} - ${project.description}"
        }
    }
}

// Default task when running gradle without arguments
defaultTasks 'listProjects'
