plugins {
    id 'java'
    id 'idea'
    id 'io.quarkus' version "${quarkusPluginVersion}"
}

// Import native build detection utilities
apply from: 'gradle/native-detection.gradle'

// Configure build mode (native-only)
configureNativeBuild()

afterEvaluate {
    def jvmType = getNativeJVMType()
    println "ğŸ” Native Build Environment:"
    println "   GraalVM: ${isGraalVM() ? 'âœ… Detected' : 'âŒ Not detected'}"
    println "   Mandrel: ${isMandrel() ? 'âœ… Detected' : 'âŒ Not detected'}"
    println "   Native Capable JVM: ${isNativeCapableJVM() ? 'âœ… ' + jvmType : 'âŒ Not detected'}"
    println "   Native Image: ${isNativeImageAvailable() ? 'âœ… Available' : 'âŒ Not available'}"
    println "   Java Vendor: ${System.getProperty('java.vendor')}"
    println "   Java Runtime: ${System.getProperty('java.runtime.name')}"
    println "   Java VM: ${System.getProperty('java.vm.name')}"
    println "   Java Home: ${System.getProperty('java.home')}"

    println "ğŸ”¥ Build Mode: NATIVE BINARY (ONLY)"
    println "ğŸ“¦ Output: ${rootProject.name}-${version}-runner"
    println "ğŸš€ Container Build: ${System.getProperty('quarkus.native.container-build')}"
}

group = 'org.example'
version = '0.1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

java {
    // Use Java 24 to match your setup
    sourceCompatibility = JavaVersion.VERSION_24
    targetCompatibility = JavaVersion.VERSION_24
}

// Get all source files from this project and bundle them up in
// *-sources.jar
tasks.register('sourceJar', Jar) {
    from sourceSets.main.allJava
    archiveClassifier = 'sources'
}

idea {
    module {
        downloadJavadoc = true
    }
}

dependencies {
    implementation enforcedPlatform("${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}")
    implementation 'io.quarkus:quarkus-resteasy-reactive'
    implementation 'io.quarkus:quarkus-arc'

    // Native image support
    implementation 'io.quarkus:quarkus-container-image-docker'

    testImplementation 'io.quarkus:quarkus-junit5'
    testImplementation 'io.rest-assured:rest-assured'
}

tasks.named('quarkusBuild') {
    doFirst {
        def jvmType = getNativeJVMType()
        println "ğŸ”¥ Starting Quarkus Native Build for ${rootProject.name}-${version}-runner"
        println "âš™ï¸  Java Version: ${System.getProperty('java.version')}"
        println "âš™ï¸  Native JVM Type: ${jvmType}"
        println "âš™ï¸  Java Home: ${System.getProperty('java.home')}"
        println "âš™ï¸  Memory Config: ${project.findProperty('quarkus.native.native-image-xmx')}"
        println "âš™ï¸  Build Args: ${project.findProperty('quarkus.native.additionalBuildArgs')}"

        // Additional native image validation before build
        if (!isNativeImageAvailable()) {
            throw new GradleException("Native image tool not found. Cannot proceed with native build.")
        }
    }
}

// Custom task to display build settings
task displayBuildSettings {
    doLast {
        def jvmType = getNativeJVMType()
        println """
        =========================================================
        QUARKUS NATIVE-ONLY BUILD CONFIGURATION
        =========================================================
        âš™ï¸  Quarkus Version: ${quarkusPlatformVersion}
        âš™ï¸  Java Version: ${java.sourceCompatibility}
        âš™ï¸  Native JVM: ${isNativeCapableJVM() ? 'âœ… ' + jvmType : 'âŒ Not detected'}
        âš™ï¸  GraalVM: ${isGraalVM() ? 'âœ… Detected' : 'âŒ Not detected'}
        âš™ï¸  Mandrel: ${isMandrel() ? 'âœ… Detected' : 'âŒ Not detected'}
        âš™ï¸  Native Image: ${isNativeImageAvailable() ? 'âœ… Available' : 'âŒ Not available'}
        âš™ï¸  Build Mode: NATIVE BINARY (EXCLUSIVE)
        âš™ï¸  Container Build: ${System.getProperty('quarkus.native.container-build')}

        ğŸ“¦  Build Output: ${rootProject.name}-${version}-runner

        This build will produce:
        - Native executable for your current platform
        - Ultra-fast startup time (< 100ms)
        - Low memory footprint (< 50MB)
        - No JVM required for execution

        Native JVM: ${jvmType}
        Test endpoint: curl localhost:8080/hello
        =========================================================
        """
    }
}

// Hook the display task to the build process
build.dependsOn displayBuildSettings

// Add task to check native build environment
task checkNativeEnvironment {
    doLast {
        def jvmType = getNativeJVMType()
        def detailedInfo = getDetailedJVMInfo()

        println "ğŸ” Native Build Environment Check:"
        println "   Current JVM: ${detailedInfo.vendor} ${detailedInfo.javaVersion}"
        println "   Runtime Name: ${detailedInfo.runtime}"
        println "   VM Name: ${detailedInfo.vmName}"
        println "   VM Version: ${detailedInfo.vmVersion}"
        println "   Java Home: ${detailedInfo.javaHome}"
        println "   Mandrel in Path: ${detailedInfo.mandrelInPath}"
        println "   GraalVM: ${isGraalVM() ? 'âœ… Detected' : 'âŒ Not detected'}"
        println "   Mandrel: ${isMandrel() ? 'âœ… Detected' : 'âŒ Not detected'}"
        println "   Native Capable: ${isNativeCapableJVM() ? 'âœ… ' + jvmType : 'âŒ Not detected'}"
        println "   Native Image: ${isNativeImageAvailable() ? 'âœ… Available' : 'âŒ Not available'}"

        // Show release file content for debugging
        println "\nğŸ“„ Release File Content:"
        println detailedInfo.releaseContent

        // Check native-image version if available
        if (isNativeImageAvailable()) {
            try {
                def process = 'native-image --version'.execute()
                process.waitFor()
                if (process.exitValue() == 0) {
                    println "\nğŸ”§ Native Image Version:"
                    process.text.split('\n').each { line ->
                        if (line.trim()) {
                            println "     ${line.trim()}"
                        }
                    }
                }
            } catch (Exception e) {
                println "\nğŸ”§ Native Image Version: Could not determine"
            }
        }

        if (!isNativeCapableJVM() || !isNativeImageAvailable()) {
            println "\nğŸ’¡ To enable native builds:"
            println "   Option 1 - GraalVM:"
            println "     1. Install GraalVM from https://www.graalvm.org/downloads/"
            println "     2. Set JAVA_HOME to point to GraalVM installation"
            println "     3. Install native-image: gu install native-image"
            println "   Option 2 - Mandrel:"
            println "     1. Install Mandrel from https://github.com/graalvm/mandrel/releases"
            println "     2. Set JAVA_HOME to point to Mandrel installation"
            println "     3. native-image is included with Mandrel"
            println "   4. Verify: native-image --version"
            println "\nâš ï¸  This project requires GraalVM or Mandrel with native-image for building."
        } else {
            println "\nğŸ‰ Native build environment is ready with ${jvmType}!"
        }
    }
}

// Add task to verify native executable after build
task verifyNativeExecutable {
    dependsOn 'quarkusBuild'
    doLast {
        def nativeExecutable = file("build/${rootProject.name}-${version}-runner")
        if (nativeExecutable.exists()) {
            println "âœ… Native executable created successfully:"
            println "   ğŸ“ Location: ${nativeExecutable.absolutePath}"
            println "   ğŸ“ Size: ${String.format('%.2f MB', nativeExecutable.length() / 1024.0 / 1024.0)}"
            println "   ğŸš€ Run with: ./${nativeExecutable.name}"
            println "   ğŸ—ï¸  Built with: ${getNativeJVMType()}"
        } else {
            println "âŒ Native executable not found at expected location"
        }
    }
}

// Hook verification to build
build.finalizedBy verifyNativeExecutable

// Add task for cross-platform builds
task buildForRaspberryPi {
    group = 'build'
    description = 'Build native executable for Raspberry Pi (ARM64)'

    doFirst {
        System.setProperty('quarkus.profile', 'raspberry')
        System.setProperty('quarkus.native.container-build', 'true')
        System.setProperty('quarkus.native.container-runtime', 'docker')
        println "ğŸ”¥ Building for Raspberry Pi (ARM64) using container build..."
        println "ğŸ³ Using Mandrel builder image for ARM64 compatibility"
    }

    finalizedBy 'quarkusBuild'
}
